package slickdemo

import cats.effect.{IO, IOApp}
import cats.effect.unsafe.implicits.global
import utils._
import slick.jdbc.PostgresProfile
import slick.lifted
import slickdemo.Connection.db
import utilsScala2.general.DebugWrapper

import java.time.LocalDate
import java.util.concurrent.Executors
import scala.concurrent.{Await, ExecutionContext, Future}
import scala.util.{Failure, Success}

/**
 *   To use this we first need to run the postgress docker file in ~/Developer/projects/postgress.. then docker-compose up
 *
 *    https://rockthejvm.com/articles/getting-started-with-scala-slick/
 *
 *
 *
 * @param profile
 */

class MovieAction(val profile: PostgresProfile) {

  import profile.api._

  lazy val movieTable = TableQuery[MovieTable]
  class MovieTable(tag: Tag) extends Table[Movie](tag, Some("movies"), "Movie") {
    def id = column[Long]("movie_id", O.PrimaryKey, O.AutoInc)
    def name = column[String]("name")
    def releaseDate = column[LocalDate]("release_date")
    def lengthInMin = column[Int]("length_in_min")
    override def * = (id, name, releaseDate, lengthInMin) <> (Movie.tupled, Movie.unapply)
  }

}

object SlickTables extends MovieAction(PostgresProfile)

import PostgresProfile.profile.api._
object Connection {
  val db = Database.forConfig("postgres")
}

object Main extends IOApp.Simple {

  import scala.concurrent.ExecutionContext.Implicits.global

  val shawshank = Movie(1L, "Shawshank Redemption", LocalDate.of(1994, 4, 2), 162)
  val godfather = Movie(2L, "The Godfather", LocalDate.of(1994, 4, 2), 162)
  val godfather2 = Movie(3L, "The Godfather 2", LocalDate.of(1994, 4, 2), 162)

  def insertMovie(movie: Movie): Future[Int] = {
    val insertQuery = SlickTables.movieTable += movie
    Connection.db.run(insertQuery)
  }

//  val result = insertMovie(shawshank)

  import scala.concurrent.duration._

//  println(Await.result(result, 3.seconds))

//  val result2 = insertMovie(godfather)
//
//
//  println(Await.result(result, 3.seconds))
//
//
//  val insertQueryWithReturn = SlickTables.movieTable.returning(SlickTables.movieTable) += godfather2
//  val movieFuture: Future[Movie] = Connection.db.run(insertQueryWithReturn)
//
//  println(Await.result(movieFuture, 3.seconds))


  // we can ensure movie_id using instead of autogenerated by using forceInsert e.g
  // val forceInsertQuery = SlickTables.movieTable forceInsert movie

  // multiple movies at a time

//  val insertBatchQuery = SlickTables.movieTable.returning(SlickTables.movieTable) ++= Seq(godfather, godfather2)
//  val f1 = Connection.db.run(insertBatchQuery)
//  println(Await.result(f1, 3.seconds))


//  f1.onComplete {
//    case Success(value) => println(s"value is $value")
//    case Failure(t) => println(s"error $t")
//  }

//  val movies: Future[Seq[Movie]] = Connection.db.run(SlickTables.movieTable.result)
//  println(Await.result(movies, 3.seconds))
//
//  def findMovieByName(name: String): Future[Option[Movie]] = {
//    db.run(SlickTables.movieTable.filter(_.name === name).result.headOption)
//  }
//
  def findMoviesByName(name: String) = {
    db.run(SlickTables.movieTable.filter(_.name === name).result)
  }
//
//  val movieSelect = findMoviesByName("The Godfather")
//  println(Await.result(movieSelect, 3.seconds))
//
//
//  val moviesSelect = findMoviesByName("Shawshank Redemption")
//  println(Await.result(moviesSelect, 3.seconds))
//
//  val movieSelect2 = findMoviesByName("The Godfather")
//  println(Await.result(movieSelect2, 3.seconds))

//  val deleteQuery = SlickTables.movieTable.delete
//
//  println(Await.result(db.run(deleteQuery), 3.seconds))
//
//
//  val movieSelect1 = findMoviesByName("The Godfather 2")
//  println(Await.result(movieSelect1, 3.seconds))


  // the scenario is as follows
  // 1. Insert 3 records - The Godfather (x2) and Shawshank Redemption
  // 2. Start a transaction
  //    - delete all records with name godfather
  //    - select all records with name godfather
  //    - add those from the select
  // what do you expect just shawshank..but you have shawshank + 2 godfathers still


  //  val insertBatchQuery = SlickTables.movieTable.returning(SlickTables.movieTable) ++= Seq(godfather, godfather2)
  //  val f1 = Connection.db.run(insertBatchQuery)
  //  println(Await.result(f1, 3.seconds))

  import cats.effect.unsafe.implicits.global



  //res.unsafeRunSync()

  def doQueries() = {
    for {
      _ <- IO(db.run(SlickTables.movieTable.delete))
      _ <- IO.fromFuture(IO(insertMovie(godfather)))
      s <- IO.fromFuture(IO(db.run(SlickTables.movieTable.filter(_.name === "The Godfather").result)))
    } yield s
  }

  override def run: IO[Unit] = {

    //val i = IO.fromFuture(IO(insertMovie(godfather)))
    doQueries().debug1.void
  }
}